# 令和に再開する X680x0 C言語 プログラミング その1

v1.0 2023.1.2 tantan

### はじめに

X68000Z の登場を機に一気に盛り上がりを見せている X680x0界隈、自分も含めて久しぶりにC言語で68のプログラミングを楽しもうかなと思っている方も多いと思います。
自分はこの25年ほど仕事・趣味含めてC言語に触れておらずすっかり忘れていたのですが、触っているうちに色々と思い出してきました。

その上で、今ならこういう書き方をした方が分かりやすいのではないか？安全ではないか？といった気づきがいくつかありましたので、覚書として記録していきます。
インラインアセンブラでゴリゴリと最適化という方向ではないので悪しからず。

---

### C言語はオブジェクト指向ではない

すべてのプログラミング言語がオブジェクト指向というわけではありませんが、今主流のものを見ると、多かれ少なかれその影響を受けている言語が多いと思います。
しかしながらC言語は言語としてはそういったサポートがさっぱりありません。(もしかしたら最近の言語仕様ではあるのかもしれませんが、調べていません)

オブジェクト指向系の言語に慣れていると、データとメソッドはまとめてクラスとして定義し、インスタンス化することで安全かつ分かりやすく感覚的に...というプログラミングスタイルをしたくなります。
ところがC言語の場合は、ある程度の機能単位で関数群をえいやっと分けて複数のファイルに小分けする。
小分けした先でグローバル変数やマクロなどを定義したら名前空間もパッケージも無いので衝突が気になったりとなかなかすっきりしません。
せいぜい関数に static 宣言をして他から呼ばれないようにプロテクトするくらいです。

ではどうしたら良いのか。

実はCの標準ライブラリでもX680x0のIOCSコールの設計にもみられるのですが、このあたりをうまく解決するための一つの方法が、

"状態を保持するための構造体を定義し、その実体とポインタを持ち回る。"

です。具体的にはこんな奴です。

    FILE* fp = fopen("hogehoge.txt","r");
    fseek(fp,1,SEEK_CUR);
    fclose(fp);

    struct BOXPTR box = { 0 };
    box.x1 = 0;
    box.y1 = 0;
    box.x2 = 299;
    box.y2 = 199;
    box.color = 1;
    box.linestyle = 0xffff;
    BOX(&box);

こんな文脈で出てくるファイルポインタとかBOXPTR構造体とかです。

こうした構造体は複数の属性を中にひと固まりとして持てます。持てないのはメソッドです。
であるならば、この構造体を操作する関数群をひとまとめに定義し、それらの関数を呼ぶ時は常にこの構造体インスタンスへのポインタを渡してあげることで、なんちゃってオブジェクト指向が実現できると言えます。

別の構造体を定義すれば別のインスタンスというわけです。これでステートフルなクラスっぽくなります。

    // prototype declarations for png
    void png_init(PNG_DECODE_HANDLE* png);
    void png_set_header(PNG_DECODE_HANDLE* png, PNG_HEADER* png_header);
    void png_close(PNG_DECODE_HANDLE* png);
    int png_load(PNG_DECODE_HANDLE* png, const char* png_file_name );
    int png_describe(PNG_DECODE_HANDLE* png, const char* png_file_name);

こんな感じです。

逆にステートレスな static メソッドしかないようなユーティリティクラスの場合はわざわざそこまでやらなくとも、関数のグルーピングと名前付けの工夫だけで良いかと思います。

これですべてが解決するわけではありませんが、少しだけコーディングしやすくなりました。

---

### try - catch

C言語でプログラムを書いていて困るのが例外処理です。Exception を投げたくてもそんなものはないので、ネストをとっても深くするか、
異常判定をするたびに、そこまで確保したリソースを解放して途中でreturnするか、みたいなコーディングになりがちです。

ここで役に立つのは禁断の `goto` です。関数の最後の方にラベルを振った上でリソース解放の処理をまとめておき、途中で異常が発生したらそこまで `goto` してしまえばいいのです。
確かに昔は `goto` は使うべきではない、というのが強い考え方でした。しかし無理にgotoを使わずに関数内のあちこちからreturnしてしまうようなコードもこれもまた品質に影響がでやすいものになります。

C言語の `goto` は try-catch の置き換えと割り切って今は使うようになりました。

        int rc = 0;

        ....

        if (異常1発生) {
            rc = 1;
            goto catch;
        }
        
        ....
        
        if (異常2発生) {
            rc = 2;
            goto catch;
        }
        
        ....


    catch:
        if (buffer1 != NULL) {
            free(buffer1);
            buffer1 = NULL;
        }
        if (fp != NULL) {
            fclose(fp);
            fp = NULL;
        }
        return rc;
    }

こんな感じですかね。

---



