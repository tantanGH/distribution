# 令和に再開する X680x0 C言語 プログラミング その1

v1.0 2023.1.2 tantan

### はじめに

X68000Z の登場を機に一気に盛り上がりを見せている X680x0界隈、自分も含めて久しぶりにC言語で68のプログラミングを楽しもうかなと思っている方も多いと思います。
自分はこの25年ほど仕事・趣味含めてC言語に触れておらずすっかり忘れていたのですが、触っているうちに色々と思い出してきました。

その上で、今ならこういう書き方をした方が分かりやすいのではないか？安全ではないか？といった気づきがいくつかありましたので、覚書として記録していきます。
インラインアセンブラでゴリゴリと最適化という方向ではないので悪しからず。

---

### C言語はオブジェクト指向ではない

すべてのプログラミング言語がオブジェクト指向というわけではありませんが、今主流のものを見ると、多かれ少なかれその影響を受けている言語が多いと思います。
しかしながらC言語は言語としてはそういったサポートがさっぱりありません。(もしかしたら最近の言語仕様ではあるのかもしれませんが、調べていません)

オブジェクト指向系の言語に慣れていると、データとメソッドはまとめてクラスとして定義し、インスタンス化することで安全かつ分かりやすく感覚的に...というプログラミングスタイルをしたくなります。
ところがC言語の場合は、ある程度の機能単位で関数群をえいやっと分けて複数のファイルに小分けする。
小分けした先でグローバル変数やマクロなどを定義したら名前空間もパッケージも無いので衝突が気になったりとなかなかすっきりしません。
せいぜい関数に static 宣言をして他から呼ばれないようにプロテクトするくらいです。

ではどうしたら良いのか。

実はCの標準ライブラリでもX680x0のIOCSコールの設計にもみられるのですが、このあたりをうまく解決するための一つの方法が、

"状態を保持するための構造体を定義し、その実体とポインタを持ち回る。"

です。具体的にはこんな奴です。

    FILE* fp = fopen("hogehoge.txt","r");
    fseek(fp,1,SEEK_CUR);
    fclose(fp);

    struct BOXPTR box = { 0 };
    box.x1 = 0;
    box.y1 = 0;
    box.x2 = 299;
    box.y2 = 199;
    box.color = 1;
    box.linestyle = 0xffff;
    BOX(&box);

こんな文脈で出てくるファイルポインタとかBOXPTR構造体とかです。

こうした構造体は複数の属性を中にひと固まりとして持てます。持てないのはメソッドです。
であるならば、この構造体を操作する関数群をひとまとめに定義し、それらの関数を呼ぶ時は常にこの構造体インスタンスへのポインタを渡してあげることで、なんちゃってオブジェクト指向が実現できると言えます。

別の構造体を定義すれば別のインスタンスというわけです。これでステートフルなクラスっぽくなります。

    // prototype declarations for png
    void png_init(PNG_DECODE_HANDLE* png);
    void png_set_header(PNG_DECODE_HANDLE* png, PNG_HEADER* png_header);
    void png_close(PNG_DECODE_HANDLE* png);
    int png_load(PNG_DECODE_HANDLE* png, const char* png_file_name );
    int png_describe(PNG_DECODE_HANDLE* png, const char* png_file_name);

こんな感じです。

逆にステートレスな static method しかないユーティリティクラスの場合はわざわざそこまでやらなくとも、関数のグルーピングと名前付けの工夫だけで良いかと思います。

これですべてが解決するわけではありませんが、少しだけコーディングしやすくなりました。

---

### try - catch

C言語でプログラムを書いていて困るのが例外処理です。Exception を投げたくてもそんなものはないので、ネストをとっても深くするか、
異常判定をするたびに、そこまで確保したリソースを解放して途中でreturnするか、みたいなコーディングになりがちです。

ここで役に立つのは禁断の `goto` です。関数の最後の方にラベルを振った上でリソース解放の処理をまとめておき、途中で異常が発生したらそこまで `goto` してしまえばいいのです。
確かに昔は `goto` は使うべきではない、というのが強い考え方でした。しかし無理にgotoを使わずに関数内のあちこちからreturnしてしまうようなコードもこれもまた品質に影響がでやすいものになります。

C言語の `goto` は try-catch の置き換えと割り切って今は使うようになりました。

        int rc = 0;

        ....

        if (異常1発生) {
            rc = 1;
            goto catch;
        }
        
        ....
        
        if (異常2発生) {
            rc = 2;
            goto catch;
        }
        
        ....


    catch:
        if (buffer1 != NULL) {
            free(buffer1);
            buffer1 = NULL;
        }
        if (fp != NULL) {
            fclose(fp);
            fp = NULL;
        }
        return rc;
    }

こんな感じですかね。

---

### クロスコンパイル環境

今回 X680x0 C言語プログラミングを再開してみて一番驚いたのが、最新の gcc でのクロスコンパイル環境が整っていたことです。
自分が実機を触っていた頃は gcc 1.x 真里子版が主流で、Charlie版 gcc2 が出たくらいでした。
今の gcc ってバージョン 12 ですよ！ 

クロスコンパイル環境を使うと何が嬉しいかと言えば、手慣れた環境で超高速ビルドできるところです。
もちろんエミュレータでMPU速度を上げてもコンパイルしても速いのですが、エディタは使い勝手を考えるとどうしても現代のものを使いたいですね。

といっても macOS の terminal で emacs も普通に使ってますけども。
sjis/utf8 のハンドリングがやりやすいです。`set-buffer-file-coding-system` とかで。

gccの吐く警告やエラーメッセージも「ここはこうなんじゃないか」まで指摘してくれて、非常にありがたいです。
デバックの効率が昔と全然違います。

ということで今時点ではほぼ100%クロスコンパイル環境xdev68kを使っていますが、気になるところといえば、
* 最適化オプションを有効にするとスーパーバイザモードからユーザモードに戻って来れない
* リンクが失敗することがある

という感じでしょうか。なので過去のソースをそのままコンパイルしてちゃんとビルドできて動くかというとそこは検証が必要なようです。
それを差し引いても圧倒的に使いやすいので、今はxdev68k以外の利用はちょっと考えられないかな、と思ってます。

ブロック先頭以外での変数宣言とか、// コメントがオプションなしで普通に通るとか、使いやすくなってますね。
ただあまりやりすぎるとソースを共有しようと思った時にクロスコンパイル必須になってしまう可能性はありますけども。

---





